//  recsched_bkgd - Background server application retrieves schedule data, performs recordings,
//  transcodes recordings in to H.264 format for iTunes, iPod etc.
//  
//  Copyright (C) 2007 Andrew Kimpton
//  
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//  
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//  
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

/*-
 * WSDL stubs for:  tvDataDelivery.wsdl
 *   Generated by:  awk
 *           Date:  Fri Jan 12 11:21:07 2007
 *        Emitter:  Objective-C
 */

#import "tvDataDelivery.h"
#import "Preferences.h"
#import "RSActivityDisplayProtocol.h"
#import "recsched_bkgd_AppDelegate.h"
#import "RecSchedServer.h"
#import "RSNotifications.h"

#import <Security/Security.h>

// URL for SOAP services used to retrieve the listings
// @"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService

NSString *kTVDataDeliveryFetchFutureScheduleKey = @"fetchFutureSchedule";
NSString *kTVDataDeliveryLineupsOnlyKey = @"lineupsOnly";
NSString *kTVDataDeliveryStartDateKey = @"startDateStr";
NSString *kTVDataDeliveryEndDateKey = @"endDateStr";
NSString *kTVDataDeliveryReportProgressToKey = @"reportProgressTo";
NSString *kTVDataDeliveryDataRecipientKey = @"dataRecipient";

@implementation tvDataDelivery

static CFTypeRef deserializationCallback(WSMethodInvocationRef invocation, CFXMLTreeRef msgRoot, CFXMLTreeRef  deserializeRoot, void *info)
{
  // Create a temp file path - rather than allowing the default WebServices parser to try and handle the returned
  // XML data we just write it to a file and parse it seperately later. The WebServices parser is confused anyway
  // by a lot of the XML in this file and tries to interpret things as SOAP returned variables.
  char *tmpXMLFilePath = tempnam(NULL,"recsched.");
  NSString *xmlFilePath = [[NSString alloc] initWithCString:tmpXMLFilePath encoding:NSASCIIStringEncoding];
  free(tmpXMLFilePath);
  
  // Find the <xtvd ..> portion of the input XML - that's all we need to write out
  CFDataRef dataRef = CFXMLTreeCreateXMLData(kCFAllocatorDefault, deserializeRoot);
  NSError *anXMLParserError = [NSError alloc];
  NSXMLDocument *anXMLDoc = [[NSXMLDocument alloc] initWithData:(NSData*) dataRef options:NSXMLDocumentTidyXML error:&anXMLParserError];
  [anXMLParserError release];
  CFRelease(dataRef);

  NSXMLNode *currentNode = [anXMLDoc rootElement];
  bool foundXTVD = false;
  while (currentNode && !foundXTVD)
  {
    NSString *nodeName = [currentNode name];
    if (nodeName && ([nodeName compare:@"xtvd" options:NSCaseInsensitiveSearch] == NSOrderedSame))
    {
      foundXTVD = true;
    }
    else
      currentNode = [currentNode nextNode];
  }
  
  bool success = false;
  // Write out the piece if found
  if (foundXTVD)
  {
    [currentNode detach];
    NSXMLElement *xtvdElement = [[NSXMLElement alloc] initWithName:@"xtvd"];
    NSXMLDocument *xtvdXMLDoc = [[NSXMLDocument alloc] initWithRootElement:xtvdElement];
    [xtvdXMLDoc setCharacterEncoding:@"UTF-8"];
    [xtvdXMLDoc setVersion:@"1.0"];
    [xtvdXMLDoc setRootElement:currentNode];

    success = [[NSFileManager defaultManager] createFileAtPath:xmlFilePath contents:[xtvdXMLDoc XMLData] attributes:nil];
    [xtvdXMLDoc release];
  }
  [anXMLDoc release];
  
  // If the write was successful return a dictionary with the output file path as our 'deserialized' response
  NSDictionary *returnedDict;
  if (success)
    returnedDict = [[NSDictionary alloc] initWithObjects:[NSArray arrayWithObject:xmlFilePath] forKeys:[NSArray arrayWithObject:@"xmlFilePath"]];
  else
    returnedDict = [[NSDictionary alloc] init];
    
  [xmlFilePath release];
  return returnedDict;
}

- (id) init
{
  self = [super init];
  if (self != nil) {
    fAuthorizedRef = nil;
  }
  return self;
}

- (void) dealloc
{
  if (fAuthorizedRef)
  {
    CFRelease(fAuthorizedRef);
    fAuthorizedRef = nil;
  }
  [super dealloc];
}

	// Return the Result object.  If it hasn't
	// been fetched yet, this will asynchronously block
- (NSDictionary*) getResultDictionary
{
	if (fResult == NULL) {
		if (fAsyncTarget != NULL) {
			fAsyncTarget = NULL;
			fAsyncSelector = NULL;
		}

                WSMethodInvocationRef invocation = [self getRef];
                CFStringRef wsGeneratedMode = CFSTR("NS-WSSYNC");

		if (fResult == NULL) {
			WSMethodInvocationScheduleWithRunLoop(invocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedMode);

			while (fResult == NULL)
                          [[NSRunLoop currentRunLoop] runMode:(NSString *)wsGeneratedMode beforeDate:[NSDate distantFuture]];
                        
			WSMethodInvocationUnscheduleFromRunLoop(invocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedMode);
		}
                WSMethodInvocationSetCallBack(fRef, NULL, NULL);

		if (fResult == NULL) {
			[self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
		}
                
                // Check to see if we got an unauthorized error
                CFHTTPMessageRef responseMessage = (CFHTTPMessageRef) [fResult valueForKey:(id)kWSHTTPResponseMessage];
                if (!responseMessage)
                {
                    [self handleError:@"WSMethodInvocationInvoke failed in get response message" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
                    return nil;
                }
                int msgCode = CFHTTPMessageGetResponseStatusCode(responseMessage);

                if (msgCode == 401)
                {
                  // We're not authorized - we need to go through a little dance to resend the request with the authorization
                  fAuthorizedRef = [self genCreateInvocationRef];
                  CFHTTPMessageRef authInvocationMsgRef;
                  CFURLRef theURL = CFHTTPMessageCopyRequestURL(responseMessage);
                  authInvocationMsgRef =  CFHTTPMessageCreateRequest(NULL, CFSTR("POST"), theURL, kCFHTTPVersion1_1);
                  CFRelease(theURL);
                  
                  // Fetch the account name from the prefs file, and the password from the keychain
                  NSString *accountName = [[[NSUserDefaultsController sharedUserDefaultsController] values] valueForKey:kWebServicesSDUsernameKey];
					if ((accountName == nil) || ([accountName length] == 0))
					{
						NSLog(@"No SchedulesDirect username in the application prefs !");
						return nil;
					}
                  NSString *password;
                  const char *serverNameUTF8 = [kWebServicesSDHostname UTF8String];
                  const char *accountNameUTF8 = [accountName UTF8String];
                  const char *pathUTF8 = [kWebServicesSDPath UTF8String];
                  UInt32 passwordLength;
                  void *passwordData;
                  OSStatus status = SecKeychainFindInternetPassword(NULL,strlen(serverNameUTF8),serverNameUTF8, 0, NULL, strlen(accountNameUTF8), accountNameUTF8, strlen(pathUTF8), pathUTF8, 80, kSecProtocolTypeHTTP, kSecAuthenticationTypeDefault, &passwordLength, &passwordData, NULL);
                  
                  if (status == noErr)
                  {
                    password = [NSString stringWithCString:passwordData length:passwordLength];
                    SecKeychainItemFreeContent(NULL, passwordData);
                  }
                  else
                  {
                    password = @"";
                  }

                  CFHTTPMessageAddAuthentication(authInvocationMsgRef, responseMessage, (CFStringRef)accountName, (CFStringRef) password, NULL, false);
                  WSMethodInvocationSetProperty(fAuthorizedRef,kWSHTTPMessage,authInvocationMsgRef);
                  fResult = NULL;
                  
                  CFStringRef wsGeneratedAuthMode = CFSTR("NS-WSSYNCAUTH");
                  WSMethodInvocationAddDeserializationOverride(fAuthorizedRef,CFSTR("urn:TMSWebServices"),CFSTR("xtvd"),deserializationCallback,NULL);
                  WSMethodInvocationScheduleWithRunLoop(fAuthorizedRef, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedAuthMode);

                  while (fResult == NULL)
                    [[NSRunLoop currentRunLoop] runMode:(NSString *)wsGeneratedAuthMode beforeDate:[NSDate distantFuture]];
                  
                  WSMethodInvocationUnscheduleFromRunLoop(fAuthorizedRef, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedAuthMode);

                  if (fResult == NULL) 
                  {
                    [self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
                  }
            
                  CFRelease(authInvocationMsgRef);
                  WSMethodInvocationSetCallBack(fAuthorizedRef, NULL, NULL);
                }
                CFRelease(responseMessage);
	}
	return fResult;
}

@end; /* tvDataDelivery */

/*-
 *   Method Name:  acknowledge
 * Documentation:  <no documentation>
 */
@implementation acknowledge
- (id) resultValue
{
    return [[super getResultDictionary] objectForKey: @"downloadTimes"];    
}

- (WSMethodInvocationRef) genCreateInvocationRef
{
    NSString *endpointURL = [NSString stringWithFormat:@"http://%@%@", kWebServicesSDHostname,kWebServicesSDPath];
    return [self createInvocationRef    
               /*endpoint*/: endpointURL //@"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService"            
                 methodName: @"acknowledge"            
                 protocol: (NSString*) kWSSOAP2001Protocol            
                      style: (NSString*) kWSSOAPStyleRPC            
                 soapAction: @"urn:TMSWebServices:xtvdWebService#acknowledge"            
            methodNamespace: @"urn:TMSWebServices"            
        ];        
}

@end; /* acknowledge */


/*-
 *   Method Name:  download
 * Documentation:  <no documentation>
 */
@implementation download
- (void) setParameters:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_startTime in_endTime:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_endTime
{
    id _paramValues[] = {    
        (id)in_startTime,        
        (id)in_endTime,        
    };    
    NSString* _paramNames[] = {    
        @"startTime",        
        @"endTime",        
    };    
    [super setParameters:2 values: _paramValues names: _paramNames];    
}

- (id) resultValue
{
    return [[super getResultDictionary] objectForKey: @"xtvdResponse"];    
}

- (WSMethodInvocationRef) genCreateInvocationRef
{
    NSString *endpointURL = [NSString stringWithFormat:@"http://%@%@", kWebServicesSDHostname,kWebServicesSDPath];
    WSMethodInvocationRef anInvocationRef = [self createInvocationRef    
               /*endpoint*/: endpointURL //@"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService"            
                 methodName: @"download"            
                 protocol: (NSString*) kWSSOAP2001Protocol            
                      style: (NSString*) kWSSOAPStyleRPC            
                 soapAction: @"urn:TMSWebServices:xtvdWebService#download"            
            methodNamespace: @"urn:TMSWebServices"            
        ];        
	WSMethodInvocationSetParameters(anInvocationRef, (CFDictionaryRef) fParams, (CFArrayRef) fParamOrder);
        return(anInvocationRef);
}

@end; /* download */



@implementation xtvdWebService

+ (id) acknowledge
{
    id result = NULL;    
    acknowledge* _invocation = [[acknowledge alloc] init];    
    result = [[_invocation resultValue] retain];    
    [_invocation release];    
    return result;    
}


+ (id) download:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_startTime in_endTime:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_endTime
{
    id result = NULL;    
    download* _invocation = [[download alloc] init];    
    [_invocation setParameters: in_startTime in_endTime:in_endTime];    
    result = [[_invocation resultValue] retain];    
    [_invocation release];    
    return result;    
}

@end;


@implementation xtvdDownloadThread

- (void) performDownload:(id)downloadInfo
{
  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  size_t activityToken;
  
  NSDictionary *xtvdDownloadData = (NSDictionary*)downloadInfo;
  
  id reportProgressTo = [xtvdDownloadData valueForKey:kTVDataDeliveryReportProgressToKey];
  BOOL reportProgress = [reportProgressTo conformsToProtocol:@protocol(RSActivityDisplay)];
  
  if (reportProgress)
  {
	activityToken = [reportProgressTo createActivity];
	activityToken = [reportProgressTo setActivity:activityToken infoString:@"Downloading Schedule Data"];
	activityToken = [reportProgressTo setActivity:activityToken progressIndeterminate:YES];
  }
	
  NSDictionary *downloadResult = [xtvdWebService download:[xtvdDownloadData valueForKey:kTVDataDeliveryStartDateKey] in_endTime:[xtvdDownloadData valueForKey:kTVDataDeliveryEndDateKey]];

  if ((downloadResult == nil) || ([downloadResult valueForKey:@"xtvd"] == nil))
  {
		// Error during the download - notify the other side and return
		[[NSDistributedNotificationCenter defaultCenter] postNotificationName:RSDownloadErrorNotification object:RSBackgroundApplication userInfo:downloadResult];
		if (reportProgress)
		{
			activityToken = [reportProgressTo setActivity:activityToken progressIndeterminate:NO];
			[reportProgressTo endActivity:activityToken];
		}
		[pool release];
		return;
  }
  
  NSMutableDictionary *parserCallData = [[NSMutableDictionary alloc] initWithDictionary:downloadResult];
  if ([xtvdDownloadData valueForKey:kTVDataDeliveryLineupsOnlyKey] != nil)
  {
		[parserCallData setValue:[xtvdDownloadData valueForKey:kTVDataDeliveryLineupsOnlyKey] forKey:kTVDataDeliveryLineupsOnlyKey];
  }
  if ([xtvdDownloadData valueForKey:kTVDataDeliveryFetchFutureScheduleKey] != nil)
  {
		[parserCallData setValue:[xtvdDownloadData valueForKey:kTVDataDeliveryFetchFutureScheduleKey] forKey:kTVDataDeliveryFetchFutureScheduleKey];
    [parserCallData setValue:[xtvdDownloadData valueForKey:kTVDataDeliveryEndDateKey] forKey:kTVDataDeliveryEndDateKey];
  }
  
  if (reportProgress)
  {
	activityToken = [reportProgressTo setActivity:activityToken progressIndeterminate:NO];
	[reportProgressTo endActivity:activityToken];
  }
  if ([[xtvdDownloadData valueForKey:kTVDataDeliveryDataRecipientKey] respondsToSelector:@selector(handleDownloadData:)])
    [[xtvdDownloadData valueForKey:kTVDataDeliveryDataRecipientKey] performSelector:@selector(handleDownloadData:) withObject:parserCallData];

  [pool release];
}

@end;

/*-
 * End of WSDL document at tvDataDelivery.wsdl
 */
